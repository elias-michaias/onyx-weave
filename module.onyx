package main

ext :: #compiler_extension "ext.onyx" {fx}
fx :: ext.fx

use core {
    printf, println, stdio, Result
}

use core.io { 
    Reader 
}

FxHandleable :: interface (T: type_expr) {
    t as T
    t->handle()
}

FxHandleableVoid :: interface (T: type_expr) {
    t as T
    { t->handle() } -> void
}

FxHandleableAs :: interface (T: type_expr, R: type_expr) {
    t as T
    { t->handle() } -> R
}


FxHasHandler :: interface (T: type_expr) {
    t as T
    t->handler()
}

run :: #match {
    macro (e: Result($T/FxHandleable, $E)) => {
        switch e {
            case .Ok as ok {
                output := ok->handle()
                return run(output)
            }
            case .Err as err {
                return .{ Err = err }
            }
        }
    }
    macro (e: Optional($T/FxHandleable)) => {
        switch e {
            case .Some as some {
                output := some->handle()
                return run(output)
            }
            case .None {
                return .{}
            }
        }
    }
    macro (e: $E/FxHandleableVoid) => {
        e->handle()
    }
    macro (e: $E/FxHandleable) => {
        output := e->handle()
        return run(output)
    }
    macro (e: $E) => e
}

Guard :: struct (E: type_expr, K: type_expr) {
    p: bool
    err: E
    k: () -> K

    handle :: #match {
        (self: Guard($E, $K)) -> #auto where FxHasHandler(Guard(E, K)) {
            return Guard.handler(self)
        }
        (self: Guard($E, $K)) -> Result(K, E) {
            if self.p do return .{ Err = self.err }
            return .{ Ok = self.k() }
        }
    }

    handleable :: interface (T: type_expr) {
        t as T
        Guard.handle(t)
    }

    t :: struct {
        empty :: macro () => Guard(void, void).{}
    }
}

guard :: (cond: bool, err: $E, k: () -> $T) => Guard(E, T).{cond, err, k}

Console :: struct {
    Read :: struct (K: type_expr) {
        k: (str) -> K

        handle :: #match {
            (self: Read($K)) -> #auto where FxHasHandler(Read(K)) {
                return Console.Read.handler(self)
            }
            (self: Read($K)) -> K {
                stdin_reader := Reader.make(&stdio.stream)
                defer Reader.free(&stdin_reader)
                line := stdin_reader |> .read_line |> .strip_whitespace
                return self.k(line)
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Read.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Read(void).{}
        }
    }
    read :: (k: (str) -> $T) => Read(T).{k}

    Print :: struct (K: type_expr) {
        p: str
        k: () -> K
        
        handle :: #match {
            (self: Print($K)) -> #auto where FxHasHandler(Print(K)) {
                return Console.Print.handler(self)
            }
            (self: Print($K)) -> K {
                printf("{}", self.p)
                return self.k()
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Print.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Print(void).{}
        }
    }
    print :: (input: str, k: () -> $T) => Print(T).{input, k}

    handle :: #match {
        (self: Console.Print($K)) => self->handle()
        (self: Console.Read($K)) => self->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Console.handle(t)
    }

    t :: struct {
        empty :: macro () => Console.{}
    }
}

Fx :: struct {
    returns :: interface (T: type_expr, R: type_expr) {
        t as T
        { check(t, R) } -> bool

        check :: #match {
            macro (self: type_expr, $r: type_expr) => check(self.{}, r)
            macro (self: Optional($T), $r: type_expr) => check(T.{}, r)
            macro (self: Result($T, $E), $r: type_expr) => check(T.{}, r)
            macro (self: $E/FxHandleableVoid, $r: type_expr) => true
            macro (self: $R/FxHandleable, $r: type_expr) => check(typeof self->handle(), r)
            macro (self: r, $r: type_expr) => true
            macro (self: $R, $r: type_expr) => {}
        }
    }
    impure :: interface (T: type_expr) {
        t as T
        t->handle()
    }
    pure :: interface (T: type_expr) {
        t as T
        { check(t) } -> bool

        check :: #match {
            macro (self: $R/FxHandleable) => {}
            macro (self: $R) => true
        }
    }
    can :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => true
                macro (self: Result($T, $E)) => true
                macro (self: $E/FxHandleableVoid) => {}
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => {}
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T/FxHandleable, $r1: type_expr) => {}
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty(), typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr, $r2: type_expr) => check(self.{}, r1, r2)
                macro (self: Optional($T), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/{r2.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr) => {}
                macro (self: $T, $r1: type_expr, $r2: type_expr) => true
            }
        }
    }
    not :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => {}
                macro (self: Result($T, $E)) => {}
                macro (self: $E/FxHandleableVoid) => true
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => true
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
    }
    must :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }

        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }
    }
    seq :: struct {
        can :: struct { 
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {}
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        not :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, r3, false, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d { 
                        return check(typeof self->handle(), r1, r2, r3, r1d, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        must :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                }
            }
        }
    }
}
