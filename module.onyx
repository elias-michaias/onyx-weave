package main

ext :: #compiler_extension "ext.onyx" {fx}
fx :: ext.fx

use core {
    printf, println, stdio, Result
}

use core.io { 
    Reader 
}

FxHandleable :: interface (T: type_expr) {
    t as T
    t->handle()
}

FxHandleableVoid :: interface (T: type_expr) {
    t as T
    { t->handle() } -> void
}

FxHandleableAs :: interface (T: type_expr, R: type_expr) {
    t as T
    { t->handle() } -> R
}

FxScopedHandler :: interface (T: type_expr) {
    t as T
    handle(t)
}

Unwrap :: struct {
    abort :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Result(K, E) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = err }
                }
            }
        }
        (self: Optional($T), k: (T) -> $K) -> Optional(K) {
            switch self {
                case .Some as s {
                    return .{ Some = k(s) }
                }
                case .None {
                    return .{}
                }
            }
        }
    }
    Suspend :: union (E: type_expr, I: type_expr, K: type_expr) {

        Err: Resumable(E, I, K)    
        Ok: K

        concretize :: macro ($T: type_expr) => T.{}

        handle :: #match {
            (e: Unwrap.Suspend($E, $T, $K/FxHandleable)) -> Unwrap.Suspend(E, T, typeof K.{} |> .handle) {
                switch e {
                    case .Ok as ok do return .{ Ok = ok->handle() }
                    case .Err as err do return .{ Err = err }
                }
            }
            (self: Unwrap.Suspend($E, $I, $K)) => K.{}
        }

        handleable :: interface (T: type_expr) {
            t as T
            Unwrap.Suspend.handle(t)
        }

        t :: struct {
            empty :: macro () => Unwrap.Suspend(void, void, void).{}
        }
    }
    suspend :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Unwrap.Suspend(E, T, K) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = Resumable(E, T, K).{err, k} }
                }
            }
        }
        (self: Optional($T), k: (T) -> $K) -> Unwrap.Suspend(void, T, K) {
            switch self {
                case .Some as s {
                    return .{ Ok = k(s) }
                }
                case .None {
                    return .{ Err = Resumable(void, T, K).{void.{}, k} }
                }
            }
        }
    }

    handle :: #match {
        (e: Unwrap.Suspend($E, $I, $K)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Unwrap.handle(t)
    }

    t :: struct {
        empty :: macro () => Unwrap.{}
    }
}


run :: #match {
    macro (e: Result($T/FxHandleable, $E), $Handle: type_expr) -> Result(typeof T.{} |> .handle |> run(Handle), E) {
        switch e {
            case .Ok as ok do return .{ Ok = run(ok->handle(), Handle) }
            case .Err as err do return .{ Err = err }
        }
    }
    macro (e: Optional($T/FxHandleable), $Handle: type_expr) => switch e {
        case .Some as some => run(some->handle(), Handle)
        case .None => .{}
    }
    macro (e: Unwrap.Suspend($E, $T, $K/FxHandleable), $Handle: type_expr) => {
        #if Handle != void {
            output := Handle.handle(e)
            return run(output, Handle)
        } else {
            output := handle(e)
            return run(output, Handle)
        }
    }
    macro (e: Unwrap.Suspend($E, $T, $K), $Handle: type_expr) => e
    macro (e: $E/FxHandleableVoid, $Handle: type_expr) => {
        #if Handle != void {
            Handle.handle(e)
        } else {
            handle(e)
        }
    }
    macro (e: $E/FxHandleable, $Handle: type_expr) => {
        #if Handle != void {
            output := Handle.handle(e)
            return run(output, Handle)
        } else {
            output := handle(e)
            return run(output, Handle)
        }
    }
    macro (e: $E, $Handle: type_expr) => e
    macro (e: $E) => run(e, void)
}

Resumable :: struct (E: type_expr, I: type_expr, K: type_expr) {
    p: E
    k: (I) -> K

    resume :: macro (self: Resumable($E, $I, $K), input: I) => self.k(input)
}

ResumableVoid :: struct (E: type_expr, K: type_expr) {
    p: E
    k: () -> K

    resume :: macro (self: ResumableVoid($E, $K)) => self.k()
}

Continuation :: struct (I: type_expr, K: type_expr) {
    k: (I) -> K

    resume :: macro (self: Continuation($I, $K), input: I) => self.k(input)
}

ContinuationVoid :: struct (K: type_expr) {
    k: () -> K

    resume :: macro (self: ContinuationVoid($K)) => self.k()
}

GuardVoid :: union (E: type_expr, K: type_expr) {

    Ok: () -> K
    Err: ResumableVoid(E, K)    

    concretize :: macro ($T: type_expr) => T.{}

    err :: (err: $E, k: () -> $T) -> GuardVoid(E, T) {
        return GuardVoid(E, T).{ Err = .{err, k} }
    }

    ok :: (err: $E, k: () -> $T) -> GuardVoid(E, T) {
        return GuardVoid(E, T).{ Ok = k }
    }

    handle :: #match {
        (self: GuardVoid($E, $K)) => {
            switch self {
                case .Ok as ok {
                    return ok()
                }
                case .Err as err {
                    return err.k()
                }
            }
        }
    }

    handleable :: interface (T: type_expr) {
        t as T
        GuardVoid.handle(t)
    }

    t :: struct {
        empty :: macro () => GuardVoid(void, void).{}
    }
}

Console :: struct {
    Read :: struct (K: type_expr) {
        k: (str) -> K

        handle :: (self: Read($K)) -> K {
            stdin_reader := Reader.make(&stdio.stream)
            defer Reader.free(&stdin_reader)
            line := stdin_reader |> .read_line |> .strip_whitespace
            return self.k(line)
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Read.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Read(void).{}
        }
    }
    read :: (k: (str) -> $T) => Read(T).{k}

    Print :: struct (K: type_expr) {
        p: str
        k: () -> K
        
        handle :: (self: Print($K)) -> K {
            printf("{}", self.p)
            return self.k()
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Print.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Print(void).{}
        }
    }
    print :: (input: str, k: () -> $T) => Print(T).{input, k}

    handle :: #match {
        (self: Console.Print($K)) => self->handle()
        (self: Console.Read($K)) => self->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Console.handle(t)
    }

    t :: struct {
        empty :: macro () => Console.{}
    }
}

Fx :: struct {
    returns :: interface (T: type_expr, R: type_expr) {
        t as T
        { check(t, R) } -> bool

        check :: #match {
            macro (self: type_expr, $r: type_expr) => check(self.{}, r)
            macro (self: Optional($T), $r: type_expr) => check(T.{}, r)
            macro (self: Result($T, $E), $r: type_expr) => check(T.{}, r)
            macro (self: $E/FxHandleableVoid, $r: type_expr) -> bool where r == void { return true }
            macro (self: $R/FxHandleable, $r: type_expr) => check(typeof self->handle(), r)
            macro (self: r, $r: type_expr) => true
            macro (self: $R, $r: type_expr) => {}
        }
    }
    impure :: interface (T: type_expr) {
        t as T
        t->handle()
    }
    pure :: interface (T: type_expr) {
        t as T
        { check(t) } -> bool

        check :: #match {
            macro (self: $R/FxHandleable) => {}
            macro (self: $R) => true
        }
    }
    can :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => true
                macro (self: Result($T, $E)) => true
                macro (self: $E/FxHandleableVoid) => {}
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => {}
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T/FxHandleable, $r1: type_expr) => {}
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty(), typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr, $r2: type_expr) => check(self.{}, r1, r2)
                macro (self: Optional($T), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/{r2.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr) => {}
                macro (self: $T, $r1: type_expr, $r2: type_expr) => true
            }
        }
    }
    cant :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => {}
                macro (self: Result($T, $E)) => {}
                macro (self: $E/FxHandleableVoid) => true
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => true
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
    }
    must :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }

        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }
    }
    seq :: struct {
        can :: struct { 
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {}
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        cant :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, r3, false, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d { 
                        return check(typeof self->handle(), r1, r2, r3, r1d, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        must :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                }
            }
        }
    }
}

handle :: #match {
    (self: $T/FxHandleable) => self->handle()
}






