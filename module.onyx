package main

ext :: #compiler_extension "ext.onyx" {fx}
fx :: ext.fx

use core {
    printf, println, stdio, Result
}

use core.io { 
    Reader 
}

FxHandleable :: interface (T: type_expr) {
    t as T
    t->handle()
}

FxHandleableVoid :: interface (T: type_expr) {
    t as T
    { t->handle() } -> void
}

FxHandleableAs :: interface (T: type_expr, R: type_expr) {
    t as T
    { t->handle() } -> R
}


FxHasHandler :: interface (T: type_expr) {
    t as T
    t->handler()
}

#inject Result {
    throw :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Result(K, E) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = err }
                }
            }
        }
        (self: Result($T, $E), k: () -> $K) -> Result(K, E) {
            switch self {
                case .Ok {
                    return .{ Ok = k() }
                }
                case .Err as err {
                    return .{ Err = err }
                }
            }
        }
    }
    guard :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Result(K, Resumable(E, T, K)) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = Resumable(E, T, K).{err, k} }
                }
            }
        }
        (self: Result($T, $E), k: () -> $K) -> Result(K, ResumableVoid(E, K)) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k() }
                }
                case .Err as err {
                    return .{ Err = ResumableVoid(E, K).{err, k} }
                }
            }
        }
    }
}

#inject Optional {
    throw :: #match {
        (self: Optional($T), k: (T) -> $K) -> Optional(K) {
            switch self {
                case .Some as s {
                    return .{ Some = k(s) }
                }
                case .None {
                    return .{}
                }
            }
        }
        (self: Optional($T), k: () -> $K) -> Optional(K) {
            switch self {
                case .Some {
                    return .{ Some = k() }
                }
                case .None {
                    return .{}
                }
            }
        }
    }
    guard :: #match {
        (self: Optional($T), k: (T) -> $K) -> Result(K, Continuation(T, K)) {
            switch self {
                case .Some as s {
                    return .{ Ok = k(s) }
                }
                case .None {
                    return .{ Err = Continuation(T, K).{k} }
                }
            }
        }
        (self: Optional($T), k: () -> $K) -> Result(K, ContinuationVoid(K)) {
            switch self {
                case .Some as s {
                    return .{ Ok = k() }
                }
                case .None {
                    return .{ Err = ContinuationVoid(T).{k} }
                }
            }
        }
    }
}

run :: #match {
    macro (e: Result($T/FxHandleable, $E)) -> Result(typeof T.{} |> .handle |> run, E) {
        switch e {
            case .Ok as ok do return .{ Ok = run(ok->handle()) }
            case .Err as err do return .{ Err = err }
        }
    }
    macro (e: Optional($T/FxHandleable)) => switch e {
        case .Some as some => run(some->handle())
        case .None => .{}
    }
    macro (e: $E/FxHandleableVoid) => {
        e->handle()
    }
    macro (e: $E/FxHandleable) => {
        output := e->handle()
        return run(output)
    }
    macro (e: $E) => e
}

Resumable :: struct (E: type_expr, I: type_expr, K: type_expr) {
    p: E
    k: (I) -> K

    resume :: macro (self: Resumable($E, $I, $K), input: I) => self.k(input)
}

ResumableVoid :: struct (E: type_expr, K: type_expr) {
    p: E
    k: () -> K

    resume :: macro (self: ResumableVoid($E, $K)) => self.k()
}

Continuation :: struct (I: type_expr, K: type_expr) {
    k: (I) -> K

    resume :: macro (self: Continuation($I, $K), input: I) => self.k(input)
}

ContinuationVoid :: struct (K: type_expr) {
    k: () -> K

    resume :: macro (self: ContinuationVoid($K)) => self.k()
}

Guard :: union (E: type_expr, I: type_expr, K: type_expr) {

    Ok: (I) -> K
    Err: Resumable(E, I, K)    

    concretize :: macro ($T: type_expr) => T.{}

    err :: (err: $E, k: ($I) -> $T) -> Guard(E, I, T) {
        return Guard(E, I, T).{ Err = .{err, k} }
    }

    ok :: (err: $E, k: ($I) -> $T) -> Guard(E, T) {
        return Guard(E, I, T).{ Ok = k }
    }

    handle :: #match {
        (self: Guard($E, $I, $K)) => K.{}
        (self: Guard($E, $I, $K), input: $I) -> Guard(E, I, typeof run(K.{})) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = run(ok(input)) }
                }
                case .Err as err {
                    return self
                }
            }
        }
    }

    handleable :: interface (T: type_expr) {
        t as T
        Guard.handle(t)
    }

    t :: struct {
        empty :: macro () => Guard(void, void, void).{}
    }
}

GuardVoid :: union (E: type_expr, K: type_expr) {

    Ok: () -> K
    Err: ResumableVoid(E, K)    

    concretize :: macro ($T: type_expr) => T.{}

    err :: (err: $E, k: () -> $T) -> GuardVoid(E, T) {
        return GuardVoid(E, T).{ Err = .{err, k} }
    }

    ok :: (err: $E, k: () -> $T) -> GuardVoid(E, T) {
        return GuardVoid(E, T).{ Ok = k }
    }

    handle :: #match {
        (self: GuardVoid($E, $K)) => {
            switch self {
                case .Ok as ok {
                    return ok()
                }
                case .Err as err {
                    return err.k()
                }
            }
        }
    }

    handleable :: interface (T: type_expr) {
        t as T
        GuardVoid.handle(t)
    }

    t :: struct {
        empty :: macro () => GuardVoid(void, void).{}
    }
}

guard :: (cond: bool, err: $E, k: () -> $T) -> Guard(E, T) {
    if cond do return Guard(E, T).{ Err = .{err, k} }
    return Guard(E, T).{ Ok = k }
}

Console :: struct {
    Read :: struct (K: type_expr) {
        k: (str) -> K

        handle :: #match {
            (self: Read($K)) -> #auto where FxHasHandler(Read(K)) {
                return Console.Read.handler(self)
            }
            (self: Read($K)) -> K {
                stdin_reader := Reader.make(&stdio.stream)
                defer Reader.free(&stdin_reader)
                line := stdin_reader |> .read_line |> .strip_whitespace
                return self.k(line)
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Read.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Read(void).{}
        }
    }
    read :: (k: (str) -> $T) => Read(T).{k}

    Print :: struct (K: type_expr) {
        p: str
        k: () -> K
        
        handle :: #match {
            (self: Print($K)) -> #auto where FxHasHandler(Print(K)) {
                return Console.Print.handler(self)
            }
            (self: Print($K)) -> K {
                printf("{}", self.p)
                return self.k()
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Print.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Print(void).{}
        }
    }
    print :: (input: str, k: () -> $T) => Print(T).{input, k}

    handle :: #match {
        (self: Console.Print($K)) => self->handle()
        (self: Console.Read($K)) => self->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Console.handle(t)
    }

    t :: struct {
        empty :: macro () => Console.{}
    }
}

Fx :: struct {
    returns :: interface (T: type_expr, R: type_expr) {
        t as T
        { check(t, R) } -> bool

        check :: #match {
            macro (self: type_expr, $r: type_expr) => check(self.{}, r)
            macro (self: Optional($T), $r: type_expr) => check(T.{}, r)
            macro (self: Result($T, $E), $r: type_expr) => check(T.{}, r)
            macro (self: Guard($E, $K/FxHandleable), $r: type_expr) => check(typeof K.handle(K.{}), r)
            macro (self: Guard($E, $K), $r: K) => true
            macro (self: $E/FxHandleableVoid, $r: type_expr) => true
            macro (self: $R/FxHandleable, $r: type_expr) => check(typeof self->handle(), r)
            macro (self: r, $r: type_expr) => true
            macro (self: $R, $r: type_expr) => {}
        }
    }
    impure :: interface (T: type_expr) {
        t as T
        t->handle()
    }
    pure :: interface (T: type_expr) {
        t as T
        { check(t) } -> bool

        check :: #match {
            macro (self: $R/FxHandleable) => {}
            macro (self: $R) => true
        }
    }
    can :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => true
                macro (self: Result($T, $E)) => true
                macro (self: $E/FxHandleableVoid) => {}
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => {}
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T/FxHandleable, $r1: type_expr) => {}
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty(), typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr, $r2: type_expr) => check(self.{}, r1, r2)
                macro (self: Optional($T), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/{r2.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr) => {}
                macro (self: $T, $r1: type_expr, $r2: type_expr) => true
            }
        }
    }
    cant :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => {}
                macro (self: Result($T, $E)) => {}
                macro (self: $E/FxHandleableVoid) => true
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => true
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
    }
    must :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }

        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }
    }
    seq :: struct {
        can :: struct { 
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {}
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        cant :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, r3, false, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d { 
                        return check(typeof self->handle(), r1, r2, r3, r1d, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        must :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                }
            }
        }
    }
}








