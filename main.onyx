package main

// Declare the fx! compiler extension
ext :: #compiler_extension "ext.onyx" {fx}

use core {
    printf, println, stdio, Result
}

use core.io { 
    Reader 
}

FxHandleable :: interface (T: type_expr) {
    t as T
    t->handle()
}

FxHandleableVoid :: interface (T: type_expr) {
    t as T
    { t->handle() } -> void
}

FxHasHandler :: interface (T: type_expr) {
    t as T
    t->handler()
}

FxSequence :: interface (T: type_expr) {
    t as T
    t->fx_next()
}

run :: #match {
    macro (e: $E/FxHandleableVoid) => {
        e->handle()
    }
    macro (e: $E/FxHandleable) => {
        output := e->handle()
        return run(output)
    }
    macro (e: $E) => e
}

Console :: struct {
    Read :: struct (K: type_expr) {
        k: (str) -> K

        handle :: #match {
            (self: Read($K)) -> K where FxHasHandler(Read(K)) {
                return Console.Read.handler(self)
            }
            (self: Read($K)) -> K {
                stdin_reader := Reader.make(&stdio.stream)
                defer Reader.free(&stdin_reader)
                line := stdin_reader |> .read_line |> .strip_whitespace
                return self.k(line)
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Read.handle(t)
        }

        t :: struct {
            new :: macro ($R: type_expr) => Console.Read(R).{}
            empty :: macro () => Console.Read(void).{}
        }
    }
    read :: (k: (str) -> $T) => Read(T).{k}

    Print :: struct (K: type_expr) {
        p: str
        k: () -> K
        
        handle :: #match {
            (self: Print($K)) -> K where FxHasHandler(Print(K)) {
                return Console.Print.handler(self)
            }
            (self: Print($K)) -> K {
                printf("{}", self.p)
                return self.k()
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Print.handle(t)
        }

        t :: struct {
            new :: macro ($R: type_expr) => Console.Print(R).{}
            empty :: macro () => Console.Print(void).{}
        }
    }
    print :: (input: str, k: () -> $T) => Print(T).{input, k}
}

fx :: struct {
    returns :: interface (T: type_expr, R: type_expr) {
        t as T
        { check(t, R) } -> bool

        check :: #match {
            macro (self: type_expr, $r: type_expr) => check(self.{}, r)
            macro (self: $E/FxHandleableVoid, $r: type_expr) => true
            macro (self: $R/FxHandleable, $r: type_expr) => check(typeof self->handle(), r)
            macro (self: r, $r: type_expr) => true
            macro (self: $R, $r: type_expr) => {}
        }
    }
    impure :: interface (T: type_expr) {
        t as T
        t->handle()
    }
    pure :: interface (T: type_expr) {
        t as T
        { check(t) } -> bool

        check :: #match {
            macro (self: $R/FxHandleable) => {}
            macro (self: $R) => true
        }
    }
    can :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T/FxHandleable, $r1: type_expr) => {}
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty(), typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr, $r2: type_expr) => check(self.{}, r1, r2)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/{r2.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr) => {}
                macro (self: $T, $r1: type_expr, $r2: type_expr) => true
            }
        }
    }
    not :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
    }
    must :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }

        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }
    }
    seq :: struct {
        can :: struct { 
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {}
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        not :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, r3, false, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d { 
                        return check(typeof self->handle(), r1, r2, r3, r1d, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        must :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                }
            }
        }
    }
}

Console.Print.handler :: macro (self: #Self) => {
    printf("{}!!!!!!\n", self.p)
    return self.k()
}

/*
program :: () => {
    return Console.read(x => {
        return Console.read(y => {
            return Console.print(y, () => {
                return 12
            })
        })
    })
}
*/

program :: () => ext.fx!{
    x: str = yield Console.read()
    y := str.concat(x, "+ bar\n")
    yield Console.print(y)
    return 12
}

console_map :: (f: () -> $T/{
    fx.returns(i32),
    fx.can._2(Console.Read.t, Console.Print.t)
}) => {
    return f()
}

main :: () {
    println(typeof program)

    program
        |> console_map 
        |> run
}
