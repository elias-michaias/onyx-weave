package main

use core {*}

#load "module.onyx"

FxError :: enum {
    PrintFoo
    GuardTriggered
}

res_fail :: () -> Result(str, FxError) { return .{ Err = .GuardTriggered } }
res_succeed :: () -> Result(str, FxError) { return .{ Ok = "bruuhhhh" } }
opt_fail :: () -> Optional(str) { return .{} }
opt_succeed :: () -> Optional(str) { return .{ Some = "swag" } }

program :: () => fx!{
    yield Console.print("init")


    x := yield Console.read()
    w := yield Console.read()
    yield Console.print(w)

    r2 := yield Unwrap.suspend(res_fail())
    msg := str.concat(r2, " pizza")
    yield Console.print(msg)

    return 19
}

console_map :: (f: () -> $T/{
    Fx.returns(i32),
    Fx.can._2(Console.t, Unwrap.t)
}) => {
    return f()
}

main :: () {
    println(typeof program)

    handle :: #match {
        (self: Console.Print($K)) => {
            printf("{}!\n", self.p)
            return self.k()
        }
        (self: $T/FxHandleable) => self->handle()
    }

    result := program
            |> console_map 
            // pass an anonymous type with handle function
            // or pass an actual defined type for reuse 
            // like `MyHandler`
            |> run(struct {
                handle :: #match {
                    (self: Console.Print($K)) => {
                        printf("{}???\n", self.p)
                        return self.k()
                    }
                    (self: $T/FxHandleable) => self->handle()
                }
            })

    println("CONTROL FLOW IS RETURNED TO MAIN.")

    switch result {
        case .Err as err {
            // any type without a .handle function = 
            // use nearest handle definition
            err->resume("pineapple on") |> run(void) |> println
        }
        case _ ---
    }
}








