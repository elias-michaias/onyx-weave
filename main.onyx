package main

use core {*}
use core.io {Reader}
use core {alloc}
use weave {*}

#load "src/module.onyx"

res_fail :: () -> Result(str, str) {
    return .{ Err = "banana" }
}

res_succeed :: () -> Result(str, str) {
    return .{ Ok = "apple" }
}

program :: () => fx!{
    z := perform Unwrap.suspend(res_succeed())
    x := perform Each.choose(.["yes", "no"])
    msg := str.concat("will finish: ", x)
    perform Console.print(msg)
    perform Each.guard(x == "yes")
    y := perform Console.read()
    perform Console.print("capture test: ")
    perform Console.print(y)
    perform Console.print(z)
    return x
}

MyHandler :: struct {
    handler :: #match {
        macro (e: Console.Print($K, $C)) => e->handle()
        macro (e: Console.Read($K, $C)) => {
            stdin_reader := Reader.make(&stdio.stream)
            defer Reader.free(&stdin_reader)
            line := stdin_reader |> .read_line |> .strip_whitespace
            return e.k(e.ctx, line)
        }
        macro (e: Each.Choose($T, $K, $C)) => e.p->map((i) use (e) => e.k(e.ctx, i) |> run)
        macro (e: Each.Guard($K, $C)) => e->handle()
        macro (e: Unwrap.Suspend($T, $I, $K, $C)) => e->handle()
    }
}

console_map :: (f: () -> $T) -> T {
    return f()
}

main :: () {
    println(typeof program)

    result := program
            |> console_map
            |> run(MyHandler)

    printf("=======\nresult type: {}\nresult: {}\n", typeof result, result)
}








