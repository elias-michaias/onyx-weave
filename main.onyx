package main

use core {*}
use core.io { Reader }
use weave {*}

#load "src/module.onyx"

FxError :: enum {
    GuardTriggered
}

res_fail    :: () -> Result(str, FxError) { return .{ Err = .GuardTriggered } }
res_succeed :: () -> Result(str, FxError) { return .{ Ok = "mushroom on" } }

program :: () => fx!{
    perform Console.print("init")

    w := perform Console.read()
    perform Console.print(w)

    r2 := perform Unwrap.suspend(res_fail())
    msg := str.concat(r2, " pizza")
    perform Console.print(msg)

    return 19
}

fx_apply :: (f: () -> $T/{
    Fx.returns(i32),
    Fx.can._2(Console.t, Unwrap.t),
    Fx.max_ctx_size(16)
}) => {
    return f()
}

main :: () {
    println(typeof program)

    result := program
            |> fx_apply
            |> run(struct {
                handler :: #match {
                    (self: Console.Print($K, $C)) => {
                        printf("{}???\n", self.p)
                        return self.k(self.ctx)
                    }
                    (self: Console.Read($K, $C)) => self->handle()
                    (e: Unwrap.Suspend($E, $T, $K/FxHandleable, $C)) -> Unwrap.Suspend(E, T, typeof K.{} |> handler |> run, C) {
                        switch e {
                            case .Ok as ok do return .{ Ok = handler(ok) |> run }
                            case .Err as err do return .{ Err = err }
                        }
                    }
                }
            })

    println("CONTROL FLOW IS RETURNED TO MAIN.")

    handler :: #match {
        (self: Console.Print($K, $C)) => {
            printf("{}!!!\n", self.p)
            return self.k(self.ctx)
        }
    }

    log := switch result {
        case .Err as err => err
            |> .resume("pineapple on") 
            |> run 
        case .Ok as ok => ok
    }

    println(log)
}
