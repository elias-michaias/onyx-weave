package main

use core {*}
use core.io {Reader}
use core {alloc}
use weave {*}

#load "src/module.onyx"

// program :: () => {
//     return Each.choose(.["yes", "no"], null, (_, c) => {
//         return Console.print(str.concat("Type something: ", c), null, _ => {
//             return Console.read(null, (_, txt) => {
//                 return Console.print("closure test (should print what you typed):", .{txt=txt}, _ => {
//                     return Console.print(_.txt, "hoopla", _ => {
//                         return _
//                     })
//                 })
//             })
//         })
//     })
// }

program :: () => fx!{
    x := perform Each.choose(.["yes", "no"])
    msg := str.concat("cool: ", x)
    perform Console.print(msg)
    y := perform Console.read()
    perform Console.print("capture test: ")
    perform Each.guard(x == "yes")
    perform Console.print(y)
    return 12
}

MyHandler :: struct {
    handler :: #match {
        macro (e: Console.Print($K, $C)) => {
            printf("{}\n", e.p)
            return e.k(e.ctx)
        }
        macro (e: Console.Read($K, $C)) => {
            stdin_reader := Reader.make(&stdio.stream)
            defer Reader.free(&stdin_reader)
            line := stdin_reader |> .read_line |> .strip_whitespace
            return e.k(e.ctx, line)
        }
        macro (e: Each.Choose($T, $K, $C)) => e.p->map((i) use (e) => e.k(e.ctx, i) |> run)
        macro (e: Each.Guard($K, $C)) => e->handle()
    }
}

console_map :: (f: () -> $T) -> T {
    return f()
}

main :: () {
    println(typeof program)

    result := program
            |> console_map
            |> run(MyHandler)

    println(typeof result)
    println(result)
}








