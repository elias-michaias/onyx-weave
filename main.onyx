package main

use core {*}
use core {alloc}
use weave {*}

#load "src/module.onyx"

FxError :: enum {
    PrintFoo
    GuardTriggered
}

res_fail :: () -> Result(str, FxError) { return .{ Err = .GuardTriggered } }
res_succeed :: () -> Result(str, FxError) { return .{ Ok = "placeholder1" } }
opt_fail :: () -> Optional(str) { return .{} }
opt_succeed :: () -> Optional(str) { return .{ Some = "placeholder2" } }

universe :: .["pineapple", "cheese", "pepperoni", "sausage"]

qux :: () => fx!{
    z := perform Console.read()
    return str.concat(z, " sandwich\n")
}

program :: () => fx!{
    r3 := perform Value.suspend("mushroom")
    msg2 := str.concat(r3, " tacos")
    perform Console.print(msg2) 

    r2 := perform Unwrap.suspend(res_fail())
    msg := str.concat(r2, " pizza")
    perform Console.print(msg)

    txt := perform Console.read()
    perform Console.print("closure test (should print what you typed): ")
    perform Console.print(txt)

    l1 := perform Each.choose(universe)
    l2 := perform Each.choose(universe)
    perform Each.guard(l1 == l2)

    l3 := perform Each.choose(universe)
    perform Each.guard(l1 == l3)

    return .[l1, l2, l3]
}

console_map :: (f: () -> $T) => {
    return f()
}

MyHandler :: struct {
    handler :: #match {
        (e: Console.Print($K)) => {
            printf("{}\n", e.p)
            return e.k()
        }
        (e: Console.Read($K)) => e->handle()
        (e: Unwrap.Suspend($E, $T, $K)) => switch e {
            case .Ok as ok => ok |> run
            case .Err as err => err->resume("foobar") |> run 
        }
        (e: Each.Choose($T, $K)) => e->handle()
        (e: Each.Guard($K)) => e->handle()
        (e: Value.Suspend(str, $K)) => e.k("toad")
        (e: Fx.Map($L, $R)) => e->handle()
    }
}

main :: () {
    println(typeof program)

    result := program
            |> console_map 
            |> run(MyHandler)
            |> Each.prune

    println(typeof result)
    println(result)
}








