package main

use core {*}

#load "module.onyx"

FxError :: enum {
    PrintFoo
    GuardTriggered
}

res_fail :: () -> Result(str, FxError) { return .{ Err = .GuardTriggered } }
res_succeed :: () -> Result(str, FxError) { return .{ Ok = "bruuhhhh" } }
opt_fail :: () -> Optional(str) { return .{} }
opt_succeed :: () -> Optional(str) { return .{ Some = "swag" } }

program :: () => fx!{
    yield Console.print("init")


    x := yield Console.read()
    w := yield Console.read()
    yield Console.print(w)

    r2 := yield Unwrap.suspend(res_fail())
    msg := str.concat(r2, " pizza")
    yield Console.print(msg)

    return 19
}

console_map :: (f: () -> $T/{
    Fx.returns(i32),
    Fx.can._2(Console.t, Unwrap.t)
}) => {
    return f()
}


main :: () {
    println(typeof program)

    handle :: #match {
        (self: Console.Print($K)) => {
            printf("{}!\n", self.p)
            return self.k()
        }
        (self: $T/FxHandleable) => self->handle()
    }

    result := () => {

        return program
            |> console_map 
            |> run([] {
                handle :: #match {
                    (self: Console.Print($K)) => {
                        printf("{}?\n", self.p)
                        return self.k()
                    }
                    (self: $T/FxHandleable) => self->handle()
                }
            })
    } 

    println("DONE! CONTROL FLOW IS RETURNED TO MAIN")

    switch result() {
        case .Err as err {
            err->resume("pineapple on") |> run([]{}) |> println
        }
        case _ ---
    }
}








