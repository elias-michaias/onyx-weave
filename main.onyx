package main

use core {*}

#load "module.onyx"

FxError :: enum {
    PrintFoo
    GuardTriggered
}

res_fail :: () -> Result(str, FxError) { return .{ Err = .GuardTriggered } }
res_succeed :: () -> Result(str, FxError) { return .{ Ok = "bruuhhhh" } }
opt_fail :: () -> Optional(str) { return .{} }
opt_succeed :: () -> Optional(str) { return .{ Some = "swag" } }

program :: () => fx!{
    perform Console.print("init")

    r2 := perform Unwrap.suspend(res_fail())
    msg := str.concat(r2, " pizza")
    perform Console.print(msg)

    w := perform Console.read()
    perform Console.print(w)

    return 12
}

console_map :: (f: () -> $T/{
    Fx.returns(i32),
    Fx.can._2(Console.t, Unwrap.t)
}) => {
    return f()
}

main :: () {
    println(typeof program)

    result := program
            |> console_map 
            // pass an anonymous type with handle function
            // or pass an actual defined type for reuse 
            // like `MyHandler`
            |> run(struct {
                handle :: #match {
                    // ask, don't state
                    (e: Console.Print($K)) => {
                        printf("{}???\n", e.p)
                        return e.k()
                    }
                    // override default short-circuit for Unwrap.Suspend
                    // if fail, resume with default value
                    // applies to all where T == str
                    (e: Unwrap.Suspend($E, str, $K)) => switch e {
                        // no type specified for run ==
                        // bubbles up to this handler; recursion-safe
                        case .Ok as ok => handle(ok) |> run
                        case .Err as err => err->resume("foobar") |> run 
                    }
                    // this is busted, I can specialize on any type parameter of any effect
                    // including using type predicates to check if the continuation
                    // is also effectful or ends in a certain primitive type
                    // this is freaking insane bro
                    e => e->handle()
                }
            })

    println(result)
}








