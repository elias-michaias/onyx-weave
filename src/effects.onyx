package weave

use core {
    alloc, printf, println, stdio, Result
}

use core.io { 
    Reader 
}

Unwrap :: struct {
    abort :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Result(K, E) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = err }
                }
            }
        }
        (self: Optional($T), k: (T) -> $K) -> Optional(K) {
            switch self {
                case .Some as s {
                    return .{ Some = k(s) }
                }
                case .None {
                    return .{}
                }
            }
        }
    }
    Suspend :: union (E: type_expr, I: type_expr, K: type_expr) {

        Err: Resumable(E, I, K)    
        Ok: K

        concretize :: macro ($T: type_expr) => T.{}

        unwrap :: macro (e: Unwrap.Suspend($E, $K, $T)) => {
            switch e {
                case .Ok as ok do return ok
                case .Err do panic("Unwrapped error type")
            }
        }

        handle :: #match {
            (e: Unwrap.Suspend($E, $T, $K/FxHandleable)) -> Unwrap.Suspend(E, T, typeof K.{} |> handler) {
                switch e {
                    case .Ok as ok do return .{ Ok = handler(ok) }
                    case .Err as err do return .{ Err = err }
                }
            }
            (self: Unwrap.Suspend($E, $I, $K)) => K.{}
        }

        handleable :: interface (T: type_expr) {
            t as T
            Unwrap.Suspend.handle(t)
        }

        t :: struct {
            empty :: macro () => Unwrap.Suspend(void, void, void).{}
        }
    }
    suspend :: #match {
        macro (self: Result($T, $E), k: (T) -> $K) -> Unwrap.Suspend(E, T, K) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = Resumable(E, T, K).{err, k} }
                }
            }
        }
        macro (self: Optional($T), k: (T) -> $K) -> Unwrap.Suspend(void, T, K) {
            switch self {
                case .Some as s {
                    return .{ Ok = k(s) }
                }
                case .None {
                    return .{ Err = Resumable(void, T, K).{void.{}, k} }
                }
            }
        }
    }

    handle :: #match {
        (e: Unwrap.Suspend($E, $I, $K)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Unwrap.handle(t)
    }

    t :: struct {
        empty :: macro () => Unwrap.{}
    }
}

Value :: struct {

    Suspend :: struct (T: type_expr, K: type_expr, C: type_expr) {
        p: T
        k: (C, T) -> K
        ctx: C

        handle :: (e: Value.Suspend($T, $K, $C)) => e.k(e.ctx, e.p)

        handleable :: interface (T: type_expr) {
            t as T
            Value.Suspend.handle(t)
        }

        t :: struct {
            empty :: macro () => Value.Suspend(void, void, void).{}
        }
    }

    suspend :: macro (value: $T, ctx: $C, continuation: (C, T) -> $K) => {
        return Value.Suspend(T, K).{value,continuation,ctx}
    }
    
    handle :: #match {
        (e: Value.Suspend($T, $K)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Value.handle(t)
    }

    t :: struct {
        empty :: macro () => Value.{}
    }

}

Console :: struct {
    Read :: struct (K: type_expr, C: type_expr) {
        k: (C, str) -> K
        ctx: C

        handle :: (self: Console.Read($K, $C)) -> K {
            stdin_reader := Reader.make(&stdio.stream)
            defer Reader.free(&stdin_reader)
            line := stdin_reader |> .read_line |> .strip_whitespace
            return self.k(self.ctx, line)
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Read.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Read(void, void).{}
        }
    }
    read :: (ctx: $C, k: (C, str) -> $T) => Console.Read(T, C).{k, ctx}

    Print :: struct (K: type_expr, C: type_expr) {
        p: str
        k: (C) -> K
        ctx: C
        
        handle :: (self: Print($K, $C)) -> K {
            printf("{}", self.p)
            return self.k(self.ctx)
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Print.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Print(void, void).{}
        }
    }
    print :: (input: str, ctx: $C, k: (C) -> $T) => Console.Print(T, C).{input, k, ctx}

    handle :: #match {
        (self: Console.Print($K, $C)) => self->handle()
        (self: Console.Read($K, $C)) => self->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Console.handle(t)
    }

    t :: struct {
        empty :: macro () => Console.{}
    }
}

Each :: struct {
    prune :: #match {
        macro (e: [] Each.Unification($T)) => {
            results: [..] T
            for i in e {
                switch i {
                    case .Unified as u do results->push(u)
                    case _ ---
                }
            }
            return Each.prune(results)
        }
        macro (e: [] [] $T) => {
            results: [..] T
            for i in e {
                for j in i {
                    results->push(j)
                }
            }
            return Each.prune(results)
        }
        macro (e) => e
    }

    Choose :: struct (T: type_expr, K: type_expr, C: type_expr) {
        p: [] T
        k: (C, T) -> K
        ctx: C

        handle :: macro (e: Each.Choose($T, $K, $C)) => e.p->map((i) use (e) => e.k(e.ctx, i) |> run)

        handleable :: interface (T: type_expr) {
            t as T
            Each.Choose.handle(t)
        }

        t :: struct {
            empty :: macro () => Each.Choose(void, void, void).{}
        }
    }

    choose :: macro (inputs: [] $T, ctx: $C, cont: (C, T) -> $K) => Each.Choose(T, K, C).{Slice.copy(inputs), cont, ctx}

    Unification :: union (T: type_expr) {
        Unified: T
        None: void
    }

    Guard :: struct (K: type_expr, C: type_expr) {
        p: bool
        k: (C) -> K
        ctx: C

        handle :: (e: Each.Guard($K, $C)) => {
            if e.p {
                return Unification(typeof run(e.k(e.ctx))).{ Unified = run(e.k(e.ctx)) }
            } else {
                return Unification(typeof run(e.k(e.ctx))).{ None = void.{} }
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Each.Guard.handle(t)
        }

        t :: struct {
            empty :: macro () => Each.Guard(void, void).{}
        }
    }

    guard :: macro (cond: bool, ctx: $C, cont: (C) -> $K) => Each.Guard(K, C).{cond, cont, ctx}

    handle :: #match {
        (e: Each.Choose($T, $K, $C)) => e->handle()
        (e: Each.Guard($K, $C)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Each.handle(t)
    }

    t :: struct {
        empty :: macro () => Each.{}
    }
}

#inject Fx {
    Map :: struct (T: type_expr, K: type_expr) {
        p: T
        k: (typeof run(T.{})) -> K

        handle :: macro (e: Fx.Map($T, $K)) => e.p |> run |> e.k

        handleable :: interface (T: type_expr) {
            t as T
            Fx.Map.handle(t)
        }

        t :: struct {
            empty :: macro () => Fx.Map(void, void).{}
        }
    }

    map :: (lhs: $T, rhs: (typeof run(T.{})) -> $K) -> Fx.Map(T, K) where FxHandleable(T), FxHandleable(K) {
        return Fx.Map(T, K).{lhs, rhs}
    } 
}
    







