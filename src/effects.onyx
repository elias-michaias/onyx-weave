package weave

use core {
    alloc, printf, println, stdio, Result
}

use core.io { 
    Reader 
}

fx_allocator: Allocator

#init () {
    fx_allocator := context.allocator
}

Unwrap :: struct {
    abort :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Result(K, E) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = err }
                }
            }
        }
        (self: Optional($T), k: (T) -> $K) -> Optional(K) {
            switch self {
                case .Some as s {
                    return .{ Some = k(s) }
                }
                case .None {
                    return .{}
                }
            }
        }
    }
    Suspend :: union (E: type_expr, I: type_expr, K: type_expr) {

        Err: Resumable(E, I, K)    
        Ok: K

        concretize :: macro ($T: type_expr) => T.{}

        unwrap :: macro (e: Unwrap.Suspend($E, $K, $T)) => {
            switch e {
                case .Ok as ok do return ok
                case .Err do panic("Unwrapped error type")
            }
        }

        handle :: #match {
            (e: Unwrap.Suspend($E, $T, $K/FxHandleable)) -> Unwrap.Suspend(E, T, typeof K.{} |> handler) {
                switch e {
                    case .Ok as ok do return .{ Ok = handler(ok) }
                    case .Err as err do return .{ Err = err }
                }
            }
            (self: Unwrap.Suspend($E, $I, $K)) => K.{}
        }

        handleable :: interface (T: type_expr) {
            t as T
            Unwrap.Suspend.handle(t)
        }

        t :: struct {
            empty :: macro () => Unwrap.Suspend(void, void, void).{}
        }
    }
    suspend :: #match {
        (self: Result($T, $E), k: (T) -> $K) -> Unwrap.Suspend(E, T, K) {
            switch self {
                case .Ok as ok {
                    return .{ Ok = k(ok) }
                }
                case .Err as err {
                    return .{ Err = Resumable(E, T, K).{err, k} }
                }
            }
        }
        (self: Optional($T), k: (T) -> $K) -> Unwrap.Suspend(void, T, K) {
            switch self {
                case .Some as s {
                    return .{ Ok = k(s) }
                }
                case .None {
                    return .{ Err = Resumable(void, T, K).{void.{}, k} }
                }
            }
        }
    }

    handle :: #match {
        (e: Unwrap.Suspend($E, $I, $K)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Unwrap.handle(t)
    }

    t :: struct {
        empty :: macro () => Unwrap.{}
    }
}

Value :: struct {

    Suspend :: struct (T: type_expr, K: type_expr) {
        p: T
        k: (T) -> K

        handle :: (e: Value.Suspend($T, $K)) => e.k(e.p)

        handleable :: interface (T: type_expr) {
            t as T
            Value.Suspend.handle(t)
        }

        t :: struct {
            empty :: macro () => Value.Suspend(void, void).{}
        }
    }

    suspend :: (value: $T, continuation: (T) -> $K) => {
        return Value.Suspend(T, K).{value,continuation}
    }
    
    handle :: #match {
        (e: Value.Suspend($T, $K)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Value.handle(t)
    }

    t :: struct {
        empty :: macro () => Value.{}
    }

}

Console :: struct {
    Read :: struct (K: type_expr) {
        k: (str) -> K

        handle :: (self: Read($K)) -> K {
            stdin_reader := Reader.make(&stdio.stream)
            defer Reader.free(&stdin_reader)
            line := stdin_reader |> .read_line |> .strip_whitespace
            return self.k(line)
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Read.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Read(void).{}
        }
    }
    read :: (k: (str) -> $T) => Read(T).{k}

    Print :: struct (K: type_expr) {
        p: str
        k: () -> K
        
        handle :: (self: Print($K)) -> K {
            printf("{}", self.p)
            return self.k()
        }

        handleable :: interface (T: type_expr) {
            t as T
            Console.Print.handle(t)
        }

        t :: struct {
            empty :: macro () => Console.Print(void).{}
        }
    }
    print :: (input: str, k: () -> $T) => Print(T).{input, k}

    handle :: #match {
        (self: Console.Print($K)) => self->handle()
        (self: Console.Read($K)) => self->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Console.handle(t)
    }

    t :: struct {
        empty :: macro () => Console.{}
    }
}

Each :: struct {
    prune :: #match {
        macro (e: [] Each.Unification($T)) => {
            results: [..] T
            for i in e {
                switch i {
                    case .Unified as u do results->push(u)
                    case _ ---
                }
            }
            return Each.prune(results)
        }
        macro (e: [] [] $T) => {
            results: [..] T
            for i in e {
                for j in i {
                    results->push(j)
                }
            }
            return Each.prune(results)
        }
        macro (e) => e
    }

    Choose :: struct (T: type_expr, K: type_expr) {
        p: [] T
        k: (T) -> K

        handle :: (e: Each.Choose($T, $K)) => e.p->map((i) use (e) => i |> e.k |> run)

        handleable :: interface (T: type_expr) {
            t as T
            Each.Choose.handle(t)
        }

        t :: struct {
            empty :: macro () => Each.Choose(void, void).{}
        }
    }

    choose :: (inputs: [] $T, cont: (T) -> $K) => Each.Choose(T, K).{Slice.copy(inputs), alloc.copy_closure(cont, context.allocator)}

    Unification :: union (T: type_expr) {
        Unified: T
        None: void
    }

    Guard :: struct (K: type_expr) {
        p: bool
        k: () -> K

        handle :: (e: Each.Guard($K)) => {
            if e.p {
                return Unification(typeof run(e.k())).{ Unified = run(e.k()) }
            } else {
                return Unification(typeof run(e.k())).{ None = void.{} }
            }
        }

        handleable :: interface (T: type_expr) {
            t as T
            Each.Guard.handle(t)
        }

        t :: struct {
            empty :: macro () => Each.Guard(void).{}
        }
    }

    guard :: (cond: bool, cont: () -> $K) => Each.Guard(K).{cond, cont}

    handle :: #match {
        (e: Each.Choose($T, $K)) => e->handle()
        (e: Each.Guard($K)) => e->handle()
    }

    handleable :: interface (T: type_expr) {
        t as T
        Each.handle(t)
    }

    t :: struct {
        empty :: macro () => Each.{}
    }
}

#inject Fx {
    Map :: struct (T: type_expr, K: type_expr) {
        p: T
        k: (typeof run(T.{})) -> K

        handle :: macro (e: Fx.Map($T, $K)) => e.p |> run |> e.k

        handleable :: interface (T: type_expr) {
            t as T
            Fx.Map.handle(t)
        }

        t :: struct {
            empty :: macro () => Fx.Map(void, void).{}
        }
    }

    map :: (lhs: $T, rhs: (typeof run(T.{})) -> $K) -> Fx.Map(T, K) where FxHandleable(T), FxHandleable(K) {
        return Fx.Map(T, K).{lhs, rhs}
    } 
}
    







