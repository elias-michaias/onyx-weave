package weave

use core {
    printf, println, stdio, Result
}

use core.io { 
    Reader 
}

FxHandleable :: interface (T: type_expr) {
    t as T
    t->handle()
}

FxHandleableVoid :: interface (T: type_expr) {
    t as T
    { t->handle() } -> void
}

FxHandleableAs :: interface (T: type_expr, R: type_expr) {
    t as T
    { t->handle() } -> R
}

FxScopedHandler :: interface (T: type_expr) {
    t as T
    handle(t)
}

run :: #match {
    macro (e: Fx.Done($T), $Handle: type_expr) => e.value
    macro (e: Result($T/FxHandleable, $E), $Handle: type_expr) -> Result(typeof T.{} |> .handle |> run(Handle), E) {
        #if Handle != void {
            switch e {
                case .Ok as ok do return .{ Ok = run(handler(ok), Handle) }
                case .Err as err do return .{ Err = err }
            }
        } else {
            switch e {
                case .Ok as ok do return .{ Ok = run(handler(ok), Handle) }
                case .Err as err do return .{ Err = err }
            }
        }
    }
    macro (e: Optional($T/FxHandleable), $Handle: type_expr) => switch e {
        #if Handle != void {
            case .Some as some => run(handler(some), Handle)
            case .None => .{}
        } else {
            case .Some as some => run(handler(ok), Handle)
            case .None => .{}
        }
    }
    macro (e: Unwrap.Suspend($E, $T, $K/FxHandleable, $C), $Handle: type_expr) => {
        #if Handle != void {
            output := Handle.handler(e)
            return run(output, Handle)
        } else {
            output := handler(e)
            return run(output, Handle)
        }
    }
    macro (e: Unwrap.Suspend($E, $T, $K, $C), $Handle: type_expr) => e
    macro (e: $E/FxHandleableVoid, $Handle: type_expr) => {
        #if Handle != void {
            Handle.handler(e)
        } else {
            handler(e)
        }
    }
    macro (e: $E/FxHandleable, $Handle: type_expr) => {
        #if Handle != void {
            output := Handle.handler(e)
            return run(output, Handle)
        } else {
            output := handler(e)
            return run(output, Handle)
        }
    }
    macro (e: $E, $Handle: type_expr) => e
    macro (e: $E) => run(e, void)
}

Fx :: struct {
    Done :: struct (T: type_expr) {
        value: T
    }

    done :: macro (e: $T) => Fx.Done(T).{e}

    returns :: interface (T: type_expr, R: type_expr) {
        t as T
        { check(t, R) } -> bool

        check :: #match {
            macro (self: type_expr, $r: type_expr) => check(self.{}, r)
            macro (self: Optional($T), $r: type_expr) => check(T.{}, r)
            macro (self: Result($T, $E), $r: type_expr) => check(T.{}, r)
            macro (self: $E/FxHandleableVoid, $r: type_expr) -> bool where r == void { return true }
            macro (self: $R/FxHandleable, $r: type_expr) => check(typeof self->handle(), r)
            macro (self: r, $r: type_expr) => true
            macro (self: $R, $r: type_expr) => {}
        }
    }
    impure :: interface (T: type_expr) {
        t as T
        t->handle()
    }
    pure :: interface (T: type_expr) {
        t as T
        { check(t) } -> bool

        check :: #match {
            macro (self: $R/FxHandleable) => {}
            macro (self: $R) => true
        }
    }
    can :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => true
                macro (self: Result($T, $E)) => true
                macro (self: Map($L, $R)) => check(typeof self.p->handle()) && check(typeof self.k(self.p |> run)->handle())
                macro (self: $E/FxHandleableVoid) => {}
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => {}
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: Map($L, $R), $r1: type_expr) => check(typeof self.p->handle(), r1) && check(typeof self.k(self.p |> run)->handle(), r1)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T/FxHandleable, $r1: type_expr) => {}
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty(), typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr, $r2: type_expr) => check(self.{}, r1, r2)
                macro (self: Optional($T), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr) => check(T.{}, r1, r2)
                macro (self: $T/{r1.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/{r2.handleable, FxHandleableVoid}, $r1: type_expr, $r2: type_expr) => true
                macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr) => check(typeof self->handle(), r1, r2)
                macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr) => {}
                macro (self: $T, $r1: type_expr, $r2: type_expr) => true
            }
        }
    }
    cant :: struct {
        fail :: interface (T: type_expr) {
            t as T
            { check(t) } -> bool

            check :: #match {
                macro (self: type_expr) => check(self.{})
                macro (self: Optional($T)) => {}
                macro (self: Result($T, $E)) => {}
                macro (self: $E/FxHandleableVoid) => true
                macro (self: $R/FxHandleable) => check(typeof self->handle())
                macro (self: $R) => true
            }
        }
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: Map($L, $R), $r1: type_expr) => check(typeof self.p->handle(), r1) && check(typeof self.k(self.p |> run)->handle(), r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => {}
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => true
            }
        }
    }
    must :: struct {
        _1 :: interface (T: type_expr, R1: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }

        _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
            t as T
            { check(t, typeof R1.empty()) } -> bool
            { check(t, typeof R2.empty()) } -> bool

            check :: #match {
                macro (self: type_expr, $r1: type_expr) => check(self.{}, r1)
                macro (self: Optional($T), $r1: type_expr) => check(T.{}, r1)
                macro (self: Result($T, $E), $r1: type_expr) => check(T.{}, r1)
                macro (self: $T/r1.handleable, $r1: type_expr) => true
                macro (self: $T/FxHandleable, $r1: type_expr) => check(typeof self->handle(), r1)
                macro (self: $T, $r1: type_expr) => {}
            }
        }
    }
    seq :: struct {
        can :: struct { 
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {}
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {}
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        cant :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => true
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d { 
                        return check(typeof self->handle(), r1, r2, r3, false, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d { 
                        return check(typeof self->handle(), r1, r2, r3, r1d, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {}
                    macro (self: $T/FxHandleableVoid, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => true
                }
            }
        }
        must :: struct {
            _2 :: interface (T: type_expr, R1: type_expr, R2: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(self.{}, r1, r2, r1d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r1d: bool) => check(T.{}, r1, r2, r1d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, true)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r1d: bool) -> #auto where r1d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r1d: bool) => check(typeof self->handle(), r1, r2, r1d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r1d: bool) => {}
                }
            }
            _3 :: interface (T: type_expr, R1: type_expr, R2: type_expr, R3: type_expr) {
                t as T
                { check(t, typeof R1.empty(), typeof R2.empty(), typeof R3.empty(), false, false) } -> bool
                
                check :: #match {
                    macro (self: type_expr, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(self.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Optional($T), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: Result($T, $E), $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(T.{}, r1, r2, r3, r1d, r2d)
                    macro (self: $T/r1.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d && !r2d {
                        return check(typeof self->handle(), r1, r2, r3, true, r2d)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r1d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r2.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r1d {
                        return check(typeof self->handle(), r1, r2, r3, r1d, true)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where !r2d {
                        return check(typeof self->handle(), r1, r2, r3, false, false)
                    }
                    macro (self: $T/r3.handleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) -> #auto where r2d {
                        return true
                    }
                    macro (self: $T/FxHandleable, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => check(typeof self->handle(), r1, r2, r3, r1d, r2d)
                    macro (self: $T, $r1: type_expr, $r2: type_expr, $r3: type_expr, $r1d: bool, $r2d: bool) => {}
                }
            }
        }
    }
}

handler :: #match {
    e => e->handle()
}
