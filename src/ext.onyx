#load "core:onyx/compiler_extension"

use onyx.compiler_extension {*}
use core {eprintf, tprintf, Result}
use core.string
use core.array

main :: () {
    ext := ExtensionContext.make("effective: direct-style effect extension")

    ext->handle_macro("fx", handle_fx_macro)

    ext->start(message_handler)
}

// Represents a parsed line from the fx! block
Line_Type :: enum {
    Unknown;
    Type_Inferred_Perform;    // x := perform Effect()
    Type_Specified_Perform;   // x: Type = perform Effect()
    Non_Binding_Perform;      // perform Effect()
    Return_Statement;       // return value
    Regular;                // any other statement
}

Parsed_Line :: struct {
    type: Line_Type;
    
    // For performs
    var_name: str;
    var_type: str;  // empty if type-inferred
    effect: str;
    
    // For return
    return_value: str;
    
    // Original line
    original: str;
    
    // Variables defined in this line (for regular statements and typed performs)
    defines_var: str;
}

handle_fx_macro :: (
    ext: &ExtensionContext,
    em: ExpansionInfo
) -> Result(str, ExpansionFailureReason) {
    body := em.body;
    body->strip_whitespace();
    
    // Parse all statements (handling multi-line parens)
    lines: [..] Parsed_Line;
    lines.allocator = context.temp_allocator;
    
    statements := collect_statements(body);
    
    for stmt in statements {
        stmt->strip_whitespace();
        if stmt.count == 0 do continue;
        
        parsed := parse_line(stmt);
        array.push(&lines, parsed);
    }
    
    if lines.count == 0 {
        return .{ Err = .NotSupported };
    }
    
    // Build the CPS transformation from inside out
    code := build_cps(lines);
    
    return .{ Ok = code };
}

// Collect statements, respecting paren matching for multi-line calls
collect_statements :: (body: str) -> [..] str {
    statements: [..] str;
    statements.allocator = context.temp_allocator;
    
    current: dyn_str;
    current.allocator = context.temp_allocator;
    
    paren_depth := 0;
    
    for line_str in body->split_iter("\n") {
        // Count parens in this line
        for i in line_str.count {
            if line_str[i] == '(' do paren_depth += 1;
            elseif line_str[i] == ')' do paren_depth -= 1;
        }
        
        // Add line to current statement
        if current.count > 0 {
            current->append(" ");
        }
        current->append(line_str);
        
        // If parens are balanced, we have a complete statement
        if paren_depth == 0 && current.count > 0 {
            // Copy the string before adding it
            stmt_copy := string.copy(current, allocator=context.temp_allocator);
            array.push(&statements, stmt_copy);
            current.count = 0; // Reset for next statement
        }
    }
    
    // Add any remaining content
    if current.count > 0 {
        stmt_copy := string.copy(current, allocator=context.temp_allocator);
        array.push(&statements, stmt_copy);
    }
    
    return statements;
}

// Extract variable name from assignment (handles both := and : Type =)
extract_defined_var :: (line: str) -> str {
    // Look for := first
    colon_eq := line->index_of(":=");
    if colon_eq != -1 {
        var_name := line[0 .. colon_eq];
        var_name->strip_whitespace();
        return var_name;
    }
    
    // Look for : Type =
    colon_idx := line->index_of(':');
    equals_idx := line->index_of('=');
    
    if colon_idx != -1 && equals_idx != -1 && colon_idx < equals_idx {
        var_name := line[0 .. colon_idx];
        var_name->strip_whitespace();
        return var_name;
    }
    
    return "";
}

parse_line :: (line: str) -> Parsed_Line {
    result: Parsed_Line;
    result.original = line;
    result.type = .Unknown;
    result.defines_var = "";
    
    // Check for return statement
    if line->starts_with("return") {
        result.type = .Return_Statement;
        // Skip "return" (6 characters) and get the rest
        if line.count > 6 {
            result.return_value = line[6 .. line.count];
            result.return_value->strip_whitespace();
        } else {
            result.return_value = "";
        }
        return result;
    }
    
    // Check for perform
    if !line->contains("perform") {
        result.type = .Regular;
        result.defines_var = extract_defined_var(line);
        return result;
    }
    
    // Parse perform patterns
    perform_index := line->index_of("perform");
    if perform_index == -1 {
        result.type = .Regular;
        result.defines_var = extract_defined_var(line);
        return result;
    }
    
    before_perform := line[0 .. perform_index];
    before_perform->strip_whitespace();
    
    after_perform := line[perform_index + 7 .. line.count];
    after_perform->strip_whitespace();
    
    result.effect = after_perform;
    
    // Non-binding perform (no assignment before perform)
    if before_perform.count == 0 {
        result.type = .Non_Binding_Perform;
        return result;
    }
    
    // Check for type-inferred binding: "x :="
    colon_eq_index := before_perform->index_of(":=");
    if colon_eq_index != -1 {
        result.var_name = before_perform[0 .. colon_eq_index];
        result.var_name->strip_whitespace();
        result.defines_var = result.var_name;
        result.type = .Type_Inferred_Perform;
        return result;
    }
    
    // Check for type-specified binding: "x: Type ="
    colon_index := before_perform->index_of(':');
    equals_index := before_perform->last_index_of('=');
    
    if colon_index != -1 && equals_index != -1 {
        result.var_name = before_perform[0 .. colon_index];
        result.var_name->strip_whitespace();
        
        result.var_type = before_perform[colon_index + 1 .. equals_index];
        result.var_type->strip_whitespace();
        
        result.defines_var = result.var_name;
        result.type = .Type_Specified_Perform;
        return result;
    }
    
    result.type = .Regular;
    return result;
}

// Simple lexical analysis: find identifiers in code that match variable names
// Improved to avoid false positives from substring matches
find_referenced_vars :: (code: str, defined_vars: [..] str) -> [..] str {
    referenced: [..] str;
    referenced.allocator = context.temp_allocator;
    
    for var in defined_vars {
        if var.count == 0 do continue;
        
        // Look for the variable name as a whole word
        idx := 0;
        while idx < code.count {
            found_idx := code[idx .. code.count]->index_of(var);
            if found_idx == -1 do break;
            
            actual_idx := idx + found_idx;
            
            // Check if this is a whole word (not part of another identifier)
            is_whole_word := true;
            
            // Check character before
            if actual_idx > 0 {
                before := code[actual_idx - 1];
                if is_identifier_char(before) {
                    is_whole_word = false;
                }
            }
            
            // Check character after
            if actual_idx + var.count < code.count {
                after := code[actual_idx + var.count];
                if is_identifier_char(after) {
                    is_whole_word = false;
                }
            }
            
            if is_whole_word {
                // Add to referenced list (avoid duplicates)
                already_added := false;
                for ref in referenced {
                    if ref == var {
                        already_added = true;
                        break;
                    }
                }
                if !already_added {
                    array.push(&referenced, var);
                }
                break;
            }
            
            idx = actual_idx + 1;
        }
    }
    
    return referenced;
}

is_identifier_char :: (c: u8) -> bool {
    if c >= 'a' && c <= 'z' do return true;
    if c >= 'A' && c <= 'Z' do return true;
    if c >= '0' && c <= '9' do return true;
    if c == '_' do return true;
    return false;
}

// Helper to insert continuation into effect call
// Handles method chains (->) and pipes (|>)
insert_continuation :: (effect: str, continuation: str) -> str {
    result: dyn_str;
    result.allocator = context.temp_allocator;
    
    // Find the LAST paren set by looking for pipe or method call operators
    // We want to insert into the final call in a chain like:
    // some_func()->build(12)->map() should become some_func()->build(12)->map(cont)
    // another_func() |> foo() should become another_func() |> foo(cont)
    
    // Find all positions of -> and |>
    last_operator_pos := -1;
    last_operator_len := 0;
    
    i := 0;
    while i < effect.count {
        // Check for |>
        if i + 1 < effect.count && effect[i] == '|' && effect[i + 1] == '>' {
            last_operator_pos = i;
            last_operator_len = 2;
            i += 2;
            continue;
        }
        
        // Check for ->
        if i + 1 < effect.count && effect[i] == '-' && effect[i + 1] == '>' {
            last_operator_pos = i;
            last_operator_len = 2;
            i += 2;
            continue;
        }
        
        i += 1;
    }
    
    // Determine which part to search for parens
    search_start := 0;
    if last_operator_pos != -1 {
        search_start = last_operator_pos + last_operator_len;
    }
    
    // Find the first opening paren after the last operator (or from start if no operator)
    effect_to_search := effect[search_start .. effect.count];
    open_paren := effect_to_search->index_of('(');
    
    if open_paren == -1 {
        // No parens? Just append them with continuation
        result->append(effect);
        result->append("(");
        result->append(continuation);
        result->append(")");
        return result;
    }
    
    // Adjust open_paren to be relative to full effect string
    open_paren += search_start;
    
    // Find the matching closing paren by counting depth
    paren_depth := 0;
    close_paren := -1;
    
    for i in open_paren .. effect.count {
        if effect[i] == '(' {
            paren_depth += 1;
        } elseif effect[i] == ')' {
            paren_depth -= 1;
            if paren_depth == 0 {
                close_paren = i;
                break;
            }
        }
    }
    
    if close_paren == -1 {
        // Malformed - no matching paren
        result->append(effect);
        result->append("(");
        result->append(continuation);
        result->append(")");
        return result;
    }
    
    // Get the content between parens
    args_section := effect[open_paren + 1 .. close_paren];
    args_section->strip_whitespace();
    
    // Build result: everything before ), then continuation, then )
    result->append(effect[0 .. close_paren]);
    
    // If there are existing args, add comma and space
    if args_section.count > 0 {
        result->append(", ");
    }
    
    result->append(continuation);
    result->append(")");
    
    // Add everything after the close paren (if anything)
    if close_paren + 1 < effect.count {
        result->append(effect[close_paren + 1 .. effect.count]);
    }
    
    return result;
}

build_cps :: (lines: [] Parsed_Line) -> str {
    code: dyn_str;
    code.allocator = context.temp_allocator;
    
    // Start from the last statement
    if lines.count == 0 {
        return "";
    }
    
    last := lines[lines.count - 1];
    
    // Determine the starting index for backwards iteration
    start_index: i32;
    
    if last.type == .Return_Statement {
        // We have an explicit return - use it as the base
        code->append("return ");
        code->append(last.return_value);
        start_index = cast(i32) lines.count - 2;
    } elseif last.type == .Type_Inferred_Perform || last.type == .Type_Specified_Perform || last.type == .Non_Binding_Perform {
        // Last line is a perform - it needs an empty continuation
        start_index = cast(i32) lines.count - 1;
    } else {
        // Last line is a regular statement - just return it
        code->append("return ");
        code->append(last.original);
        start_index = cast(i32) lines.count - 2;
    }
    
    // Track variables that need to be captured at each perform
    captures_needed: [..] [..] str;
    captures_needed.allocator = context.temp_allocator;
    
    // Initialize with empty capture lists
    for _ in 0 .. lines.count {
        empty_list: [..] str;
        empty_list.allocator = context.temp_allocator;
        array.push(&captures_needed, empty_list);
    }
    
    // Build list of variables defined before each perform
    // These are variables that CAN be captured at that perform
    vars_defined_before: [..] [..] str;
    vars_defined_before.allocator = context.temp_allocator;
    
    all_defined: [..] str;
    all_defined.allocator = context.temp_allocator;
    
    for idx in 0 .. lines.count {
        line := lines[idx];
        
        // Save all vars defined up to this point
        defined_copy: [..] str;
        defined_copy.allocator = context.temp_allocator;
        for v in all_defined {
            array.push(&defined_copy, v);
        }
        array.push(&vars_defined_before, defined_copy);
        
        // Add any new definitions
        if line.defines_var.count > 0 {
            array.push(&all_defined, line.defines_var);
        }
    }
    
    // Now determine captures: work backwards through performs
    // For each perform, check what variables from BEFORE it are referenced in the continuation
    i := cast(i32) lines.count - 1;
    while i >= 0 {
        defer i -= 1;
        
        line := lines[i];
        
        if line.type == .Type_Inferred_Perform || line.type == .Type_Specified_Perform || line.type == .Non_Binding_Perform {
            // Build ALL code that will be in this perform's continuation
            // This includes everything after this perform
            inner_code: dyn_str;
            inner_code.allocator = context.temp_allocator;
            
            for j in (i + 1) .. lines.count {
                inner_code->append(lines[j].original);
                inner_code->append(" ");
            }
            
            // Find which variables from before this perform are referenced in ALL remaining code
            vars_before := vars_defined_before[i];
            referenced := find_referenced_vars(inner_code, vars_before);
            
            for ref_var in referenced {
                array.push(&captures_needed[i], ref_var);
            }
            
            // Also propagate ALL captures from ALL downstream performs
            // Work through every perform after this one
            for j in (i + 1) .. lines.count {
                downstream_line := lines[j];
                
                if downstream_line.type == .Type_Inferred_Perform || downstream_line.type == .Type_Specified_Perform || downstream_line.type == .Non_Binding_Perform {
                    downstream_captures := captures_needed[j];
                    
                    for captured_var in downstream_captures {
                        // Check if this variable was defined before THIS perform (i)
                        var_is_from_before := false;
                        for v in vars_before {
                            if v == captured_var {
                                var_is_from_before = true;
                                break;
                            }
                        }
                        
                        // If it's from before this perform, we need to capture it too
                        if var_is_from_before {
                            // Check if we're not already capturing it
                            already_captured := false;
                            for already in captures_needed[i] {
                                if already == captured_var {
                                    already_captured = true;
                                    break;
                                }
                            }
                            
                            if !already_captured {
                                array.push(&captures_needed[i], captured_var);
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Second pass: build the CPS code backwards
    code.count = 0; // Reset code
    
    if last.type == .Return_Statement {
        code->append("return ");
        code->append(last.return_value);
    } elseif last.type == .Type_Inferred_Perform || last.type == .Type_Specified_Perform || last.type == .Non_Binding_Perform {
        // Will be handled in the loop
    } else {
        code->append("return ");
        code->append(last.original);
    }
    
    // Work backwards through performs, wrapping each in a continuation
    i = start_index;
    while i >= 0 {
        defer i -= 1;
        
        line := lines[i];
        
        // Get the captures for this perform
        captures := captures_needed[i];
        
        // Build use clause if we have captures
        use_clause: str;
        if captures.count > 0 {
            use_buf: dyn_str;
            use_buf.allocator = context.temp_allocator;
            use_buf->append(" use (");
            for j in 0 .. captures.count {
                if j > 0 do use_buf->append(", ");
                use_buf->append(captures[j]);
            }
            use_buf->append(")");
            use_clause = use_buf;
        } else {
            use_clause = "";
        }
        
        switch line.type {
            case .Type_Inferred_Perform {
                // Build continuation
                continuation: dyn_str;
                continuation.allocator = context.temp_allocator;
                continuation->append("(");
                continuation->append(line.var_name);
                continuation->append(")");
                continuation->append(use_clause);
                continuation->append(" => {\n        ");
                
                // If this is the last perform and there's no code yet, add empty body
                if code.count == 0 {
                    continuation->append("return");
                } else {
                    continuation->append(code);
                }
                
                continuation->append("\n    }");
                
                // Insert into effect call
                wrapped: dyn_str;
                wrapped.allocator = context.temp_allocator;
                wrapped->append("return ");
                wrapped->append(insert_continuation(line.effect, continuation));
                
                code = wrapped;
            }
            
            case .Type_Specified_Perform {
                // Build continuation with typed parameter
                continuation: dyn_str;
                continuation.allocator = context.temp_allocator;
                continuation->append("(");
                continuation->append(line.var_name);
                continuation->append(": ");
                continuation->append(line.var_type);
                continuation->append(")");
                continuation->append(use_clause);
                continuation->append(" => {\n        ");
                
                // If this is the last perform and there's no code yet, add empty body
                if code.count == 0 {
                    continuation->append("return");
                } else {
                    continuation->append(code);
                }
                
                continuation->append("\n    }");
                
                // Insert into effect call
                wrapped: dyn_str;
                wrapped.allocator = context.temp_allocator;
                wrapped->append("return ");
                wrapped->append(insert_continuation(line.effect, continuation));
                
                code = wrapped;
            }
            
            case .Non_Binding_Perform {
                // Build continuation with no parameters
                continuation: dyn_str;
                continuation.allocator = context.temp_allocator;
                continuation->append("()");
                continuation->append(use_clause);
                continuation->append(" => {\n        ");
                
                // If this is the last perform and there's no code yet, add empty body
                if code.count == 0 {
                    continuation->append("return");
                } else {
                    continuation->append(code);
                }
                
                continuation->append("\n    }");
                
                // Insert into effect call
                wrapped: dyn_str;
                wrapped.allocator = context.temp_allocator;
                wrapped->append("return ");
                wrapped->append(insert_continuation(line.effect, continuation));
                
                code = wrapped;
            }
            
            case .Return_Statement {
                // Already handled as last statement
                continue;
            }
            
            case .Regular, .Unknown {
                // Regular statements need to be prepended to the current code
                wrapped: dyn_str;
                wrapped.allocator = context.temp_allocator;
                wrapped->append(line.original);
                wrapped->append("\n        ");
                wrapped->append(code);
                
                code = wrapped;
            }
        }
    }
    
    // Wrap in a do block to make it an expression
    final: dyn_str;
    final.allocator = context.temp_allocator;
    final->append("do do {\n    ");
    final->append(code);
    final->append("\n}");
    
    return final;
}

message_handler :: (ext, msg) => {
    eprintf("Fx Extension Message: {p}\n", msg)

    switch msg {
        case .ExpandMacro as em {
            // All macros are handled via handle_macro above
            // This shouldn't be reached, but send NotSupported just in case
            ext->send(.{
                Expansion = .{
                    id = em.id,
                    code = .{ Err = .NotSupported }
                }
            })
        }

        case _ {}
    }
}
